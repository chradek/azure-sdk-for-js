## API Report File for "@azure/core-amqp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AccessToken } from '@azure/core-auth';
import { AmqpError } from 'rhea-promise';
import { Message as AmqpMessage } from 'rhea-promise';
import { MessageHeader as AmqpMessageHeader } from 'rhea-promise';
import { MessageProperties as AmqpMessageProperties } from 'rhea-promise';
import AsyncLock from 'async-lock';
import { Connection } from 'rhea-promise';
import { Dictionary } from 'rhea-promise';
import { isAmqpError } from 'rhea-promise';
import { isTokenCredential } from '@azure/core-auth';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { ReqResLink } from 'rhea-promise';
import { Sender } from 'rhea-promise';
import { SenderOptions } from 'rhea-promise';
import { Session } from 'rhea-promise';
import { TokenCredential } from '@azure/core-auth';
import { WebSocketImpl } from 'rhea-promise';

export { AccessToken }

export { AmqpMessage }

export { AmqpMessageHeader }

export { AmqpMessageProperties }

export { AsyncLock }

// @public
export interface AsyncLockOptions {
    domainReentrant?: boolean;
    maxPending?: number;
    Promise?: any;
    timeout?: number;
}

// @public
export class CbsClient {
    constructor(connection: Connection, connectionLock: string);
    readonly cbsLock: string;
    close(): Promise<void>;
    connection: Connection;
    readonly connectionLock: string;
    readonly endpoint: string;
    init(): Promise<void>;
    negotiateClaim(audience: string, tokenObject: AccessToken, tokenType: TokenType): Promise<CbsResponse>;
    remove(): void;
    readonly replyTo: string;
}

// @public
export interface CbsResponse {
    // (undocumented)
    correlationId: string;
    // (undocumented)
    satusDescription: string;
    // (undocumented)
    statusCode: string;
}

// @public
export enum ConditionErrorNameMapper {
    "amqp:connection:forced" = "ConnectionForcedError",
    "amqp:connection:framing-error" = "FramingError",
    "amqp:connection:redirect" = "ConnectionRedirectError",
    "amqp:decode-error" = "DecodeError",
    "amqp:frame-size-too-small" = "FrameSizeTooSmallError",
    "amqp:illegal-state" = "IllegalStateError",
    "amqp:internal-error" = "InternalServerError",
    "amqp:invalid-field" = "InvalidFieldError",
    "amqp:link:detach-forced" = "DetachForcedError",
    "amqp:link:message-size-exceeded" = "MessageTooLargeError",
    "amqp:link:redirect" = "LinkRedirectError",
    "amqp:link:stolen" = "ReceiverDisconnectedError",
    "amqp:link:transfer-limit-exceeded" = "TransferLimitExceededError",
    "amqp:not-allowed" = "InvalidOperationError",
    "amqp:not-found" = "ServiceCommunicationError",
    "amqp:not-implemented" = "NotImplementedError",
    "amqp:precondition-failed" = "PreconditionFailedError",
    "amqp:resource-deleted" = "ResourceDeletedError",
    "amqp:resource-limit-exceeded" = "QuotaExceededError",
    "amqp:resource-locked" = "ResourceLockedError",
    "amqp:session:errant-link" = "ErrantLinkError",
    "amqp:session:handle-in-use" = "HandleInUseError",
    "amqp:session:unattached-handle" = "UnattachedHandleError",
    "amqp:session:window-violation" = "SessionWindowViolationError",
    "amqp:unauthorized-access" = "UnauthorizedError",
    "client.sender:not-enough-link-credit" = "SenderBusyError",
    "com.microsoft:address-already-in-use" = "AddressAlreadyInUseError",
    "com.microsoft:argument-error" = "ArgumentError",
    "com.microsoft:argument-out-of-range" = "ArgumentOutOfRangeError",
    "com.microsoft:auth-failed" = "UnauthorizedError",
    "com.microsoft:entity-already-exists" = "MessagingEntityAlreadyExistsError",
    "com.microsoft:entity-disabled" = "MessagingEntityDisabledError",
    "com.microsoft:message-lock-lost" = "MessageLockLostError",
    "com.microsoft:message-not-found" = "MessageNotFoundError",
    "com.microsoft:message-wait-timeout" = "MessageWaitTimeout",
    "com.microsoft:no-matching-subscription" = "NoMatchingSubscriptionError",
    "com.microsoft:operation-cancelled" = "OperationCancelledError",
    "com.microsoft:partition-not-owned" = "PartitionNotOwnedError",
    "com.microsoft:precondition-failed" = "PreconditionFailedError",
    "com.microsoft:publisher-revoked" = "PublisherRevokedError",
    "com.microsoft:relay-not-found" = "RelayNotFoundError",
    "com.microsoft:server-busy" = "ServerBusyError",
    "com.microsoft:session-cannot-be-locked" = "SessionCannotBeLockedError",
    "com.microsoft:session-lock-lost" = "SessionLockLostError",
    "com.microsoft:store-lock-lost" = "StoreLockLostError",
    "com.microsoft:timeout" = "ServiceUnavailableError",
    "system:error" = "SystemError"
}

// @public
export enum ConditionStatusMapper {
    // (undocumented)
    "amqp:link:message-size-exceeded" = 403,
    // (undocumented)
    "amqp:link:stolen" = 410,
    // (undocumented)
    "amqp:not-allowed" = 400,
    // (undocumented)
    "amqp:not-found" = 404,
    // (undocumented)
    "amqp:not-implemented" = 501,
    // (undocumented)
    "amqp:resource-limit-exceeded" = 403,
    // (undocumented)
    "amqp:unauthorized-access" = 401,
    // (undocumented)
    "com.microsoft:argument-error" = 400,
    // (undocumented)
    "com.microsoft:argument-out-of-range" = 400,
    // (undocumented)
    "com.microsoft:entity-already-exists" = 409,
    // (undocumented)
    "com.microsoft:entity-disabled" = 400,
    // (undocumented)
    "com.microsoft:message-lock-lost" = 410,
    // (undocumented)
    "com.microsoft:no-matching-subscription" = 500,
    // (undocumented)
    "com.microsoft:partition-not-owned" = 410,
    // (undocumented)
    "com.microsoft:publisher-revoked" = 401,
    // (undocumented)
    "com.microsoft:server-busy" = 503,
    // (undocumented)
    "com.microsoft:session-cannot-be-locked" = 410,
    // (undocumented)
    "com.microsoft:session-lock-lost" = 410,
    // (undocumented)
    "com.microsoft:store-lock-lost" = 410,
    // (undocumented)
    "com.microsoft:timeout" = 408
}

// @public
export interface ConnectionConfig {
    connectionString: string;
    endpoint: string;
    entityPath?: string;
    host: string;
    sharedAccessKey: string;
    sharedAccessKeyName: string;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
    webSocketEndpointPath?: string;
}

// @public
export namespace ConnectionConfig {
    export function create(connectionString: string, path?: string): ConnectionConfig;
    export function validate(config: ConnectionConfig, options?: ConnectionConfigOptions): void;
}

// @public
export interface ConnectionConfigOptions {
    isEntityPathRequired?: boolean;
}

// @public
export interface ConnectionContextBase {
    cbsSession: CbsClient;
    readonly config: ConnectionConfig;
    connection: Connection;
    connectionId: string;
    readonly connectionLock: string;
    dataTransformer: DataTransformer;
    readonly negotiateClaimLock: string;
    readonly tokenCredential: SharedKeyCredential | TokenCredential;
    wasConnectionCloseCalled: boolean;
}

// @public (undocumented)
export module ConnectionContextBase {
    export function create(parameters: CreateConnectionContextBaseParameters): ConnectionContextBase;
}

// @public
export interface ConnectionProperties {
    product: string;
    userAgent: string;
    version: string;
}

// @public (undocumented)
export const Constants: {
    associatedLinkName: "associated-link-name";
    partitionKey: "x-opt-partition-key";
    sequenceNumber: "x-opt-sequence-number";
    enqueueSequenceNumber: "x-opt-enqueue-sequence-number";
    enqueuedTime: "x-opt-enqueued-time";
    scheduledEnqueueTime: "x-opt-scheduled-enqueue-time";
    offset: "x-opt-offset";
    lockedUntil: "x-opt-locked-until";
    partitionIdName: "x-opt-partition-id";
    publisher: "x-opt-publisher-name";
    viaPartitionKey: "x-opt-via-partition-key";
    deadLetterSource: "x-opt-deadletter-source";
    enqueuedTimeAnnotation: string;
    offsetAnnotation: string;
    sequenceNumberAnnotation: string;
    guidSize: 16;
    message: "message";
    error: "error";
    statusCode: "status-code";
    statusDescription: "status-description";
    errorCondition: "error-condition";
    management: "$management";
    partition: "partition";
    partitionId: "partitionId";
    readOperation: "READ";
    TLS: "tls";
    establishConnection: "establishConnection";
    defaultConsumerGroup: "$default";
    eventHub: "eventhub";
    cbsEndpoint: "$cbs";
    cbsReplyTo: "cbs";
    operationPutToken: "put-token";
    aadEventHubsAudience: "https://eventhubs.azure.net/";
    aadEventHubsScope: "https://eventhubs.azure.net//.default";
    aadServiceBusAudience: "https://servicebus.azure.net/";
    aadServiceBusScope: "https://servicebus.azure.net//.default";
    maxUserAgentLength: 512;
    vendorString: "com.microsoft";
    attachEpoch: string;
    receiverIdentifierName: string;
    enableReceiverRuntimeMetricName: string;
    timespan: string;
    uri: string;
    dateTimeOffset: string;
    sessionFilterName: string;
    receiverError: "receiver_error";
    senderError: "sender_error";
    sessionError: "session_error";
    connectionError: "connection_error";
    defaultOperationTimeoutInMs: 60000;
    defaultConnectionIdleTimeoutInMs: 60000;
    managementRequestKey: "managementRequest";
    negotiateCbsKey: "negotiateCbs";
    negotiateClaim: "negotiateClaim";
    ensureContainerAndBlob: "ensureContainerAndBlob";
    defaultPrefetchCount: 1000;
    reconnectLimit: 100;
    maxMessageIdLength: 128;
    maxPartitionKeyLength: 128;
    maxSessionIdLength: 128;
    pathDelimiter: "/";
    ruleNameMaximumLength: 50;
    maximumSqlFilterStatementLength: 1024;
    maximumSqlRuleActionStatementLength: 1024;
    maxDeadLetterReasonLength: 4096;
    maxDurationValue: 922337203685477;
    minDurationValue: -922337203685477;
    maxAbsoluteExpiryTime: number;
    aadTokenValidityMarginInMs: 5000;
    connectionReconnectDelay: 300;
    defaultMaxRetries: 3;
    defaultMaxRetriesForConnection: 150;
    defaultDelayBetweenOperationRetriesInMs: 30000;
    defaultMaxDelayForExponentialRetryInMs: 90000;
    receiverSettleMode: "receiver-settle-mode";
    dispositionStatus: "disposition-status";
    fromSequenceNumber: "from-sequence-number";
    messageCount: "message-count";
    lockTokens: "lock-tokens";
    messageIdMapKey: "message-id";
    sequenceNumberMapKey: "sequence-number";
    lockTokenMapKey: "lock-token";
    sessionIdMapKey: "session-id";
    sequenceNumbers: "sequence-numbers";
    deadLetterReason: "deadletter-reason";
    deadLetterDescription: "deadletter-description";
    propertiesToModify: "properties-to-modify";
    deadLetterName: "com.microsoft:dead-letter";
    trackingId: "com.microsoft:tracking-id";
    serverTimeout: "com.microsoft:server-timeout";
    operations: {
        putToken: string;
        read: string;
        cancelScheduledMessage: string;
        scheduleMessage: string;
        renewLock: string;
        peekMessage: string;
        receiveBySequenceNumber: string;
        updateDisposition: string;
        renewSessionLock: string;
        setSessionState: string;
        getSessionState: string;
        enumerateSessions: string;
        addRule: string;
        removeRule: string;
        enumerateRules: string;
    };
    descriptorCodes: {
        ruleDescriptionList: number;
        sqlFilterList: number;
        correlationFilterList: number;
        sqlRuleActionList: number;
        trueFilterList: number;
        falseFilterList: number;
    };
};

// @public
export interface CreateConnectionContextBaseParameters {
    config: ConnectionConfig;
    connectionProperties: ConnectionProperties;
    dataTransformer?: DataTransformer;
    isEntityPathRequired?: boolean;
    operationTimeoutInMs?: number;
    tokenCredential?: SharedKeyCredential | TokenCredential;
}

// @public
export interface DataTransformer {
    decode: (body: any) => any;
    encode: (body: any) => any;
}

// @public
export class DefaultDataTransformer implements DataTransformer {
    decode(body: any): any;
    encode(body: any): any;
}

// @public
export const defaultLock: AsyncLock;

// @public
export function delay<T>(delayInMs: number, abortSignal?: AbortSignalLike, abortErrorMsg?: string, value?: T): Promise<T>;

export { Dictionary }

// @public
export enum ErrorNameConditionMapper {
    AddressAlreadyInUseError = "com.microsoft:address-already-in-use",
    ArgumentError = "com.microsoft:argument-error",
    ArgumentOutOfRangeError = "com.microsoft:argument-out-of-range",
    ConnectionForcedError = "amqp:connection:forced",
    ConnectionRedirectError = "amqp:connection:redirect",
    DecodeError = "amqp:decode-error",
    DetachForcedError = "amqp:link:detach-forced",
    ErrantLinkError = "amqp:session:errant-link",
    FrameSizeTooSmallError = "amqp:frame-size-too-small",
    FramingError = "amqp:connection:framing-error",
    HandleInUseError = "amqp:session:handle-in-use",
    IllegalStateError = "amqp:illegal-state",
    InternalServerError = "amqp:internal-error",
    InvalidFieldError = "amqp:invalid-field",
    InvalidOperationError = "amqp:not-allowed",
    LinkRedirectError = "amqp:link:redirect",
    MessageLockLostError = "com.microsoft:message-lock-lost",
    MessageNotFoundError = "com.microsoft:message-not-found",
    MessageTooLargeError = "amqp:link:message-size-exceeded",
    MessageWaitTimeout = "com.microsoft:message-wait-timeout",
    MessagingEntityAlreadyExistsError = "com.microsoft:entity-already-exists",
    MessagingEntityDisabledError = "com.microsoft:entity-disabled",
    NoMatchingSubscriptionError = "com.microsoft:no-matching-subscription",
    NotImplementedError = "amqp:not-implemented",
    OperationCancelledError = "com.microsoft:operation-cancelled",
    PartitionNotOwnedError = "com.microsoft:partition-not-owned",
    PreconditionFailedError = "amqp:precondition-failed",
    PublisherRevokedError = "com.microsoft:publisher-revoked",
    QuotaExceededError = "amqp:resource-limit-exceeded",
    ReceiverDisconnectedError = "amqp:link:stolen",
    RelayNotFoundError = "com.microsoft:relay-not-found",
    ResourceDeletedError = "amqp:resource-deleted",
    ResourceLockedError = "amqp:resource-locked",
    SenderBusyError = "client.sender:not-enough-link-credit",
    ServerBusyError = "com.microsoft:server-busy",
    ServiceCommunicationError = "amqp:not-found",
    ServiceUnavailableError = "com.microsoft:timeout",
    SessionCannotBeLockedError = "com.microsoft:session-cannot-be-locked",
    SessionLockLostError = "com.microsoft:session-lock-lost",
    SessionWindowViolationError = "amqp:session:window-violation",
    StoreLockLostError = "com.microsoft:store-lock-lost",
    SystemError = "system:error",
    TransferLimitExceededError = "amqp:link:transfer-limit-exceeded",
    UnattachedHandleError = "amqp:session:unattached-handle",
    UnauthorizedError = "amqp:unauthorized-access"
}

// @public
export interface EventHubConnectionConfig extends ConnectionConfig {
    entityPath: string;
    getManagementAddress(): string;
    getManagementAudience(): string;
    getReceiverAddress(partitionId: string | number, consumergroup?: string): string;
    getReceiverAudience(partitionId: string | number, consumergroup?: string): string;
    getSenderAddress(partitionId?: string | number): string;
    getSenderAudience(partitionId?: string | number): string;
}

// @public
export module EventHubConnectionConfig {
    export function create(connectionString: string, path?: string): EventHubConnectionConfig;
    export function createFromConnectionConfig(config: ConnectionConfig): EventHubConnectionConfig;
    export function validate(config: EventHubConnectionConfig): void;
}

// @public
export interface EventHubConnectionStringModel {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    Endpoint: string;
    // (undocumented)
    EntityPath?: string;
    // (undocumented)
    SharedAccessKey: string;
    // (undocumented)
    SharedAccessKeyName: string;
}

// @public (undocumented)
export function executePromisesSequentially(promiseFactories: Array<any>, kickstart?: any): Promise<any>;

// @public
export type Func<T, V> = (a: T) => V;

// @public
export function getNewAsyncLock(options?: AsyncLockOptions): AsyncLock;

// @public
export interface IotHubConnectionConfig {
    connectionString: string;
    deviceId?: string;
    entityPath: string;
    host: string;
    hostName: string;
    sharedAccessKey: string;
    sharedAccessKeyName: string;
}

// @public
export namespace IotHubConnectionConfig {
    export function convertToEventHubConnectionConfig(iotHubConfig: IotHubConnectionConfig): EventHubConnectionConfig;
    export function create(connectionString: string, path?: string): IotHubConnectionConfig;
    export function validate(config: IotHubConnectionConfig): void;
}

// @public
export interface IotHubConnectionStringModel {
    // (undocumented)
    DeviceId?: string;
    // (undocumented)
    HostName: string;
    // (undocumented)
    SharedAccessKey: string;
    // (undocumented)
    SharedAccessKeyName: string;
}

// @public
export class IotSharedKeyCredential extends SharedKeyCredential {
    getToken(audience: string): AccessToken;
}

export { isAmqpError }

// @public
export function isIotHubConnectionString(connectionString: string): boolean;

// @public
export const isNode: boolean;

// Warning: (ae-forgotten-export) The symbol "NetworkSystemError" needs to be exported by the entry point index.d.ts
//
// @public
export function isSystemError(err: any): err is NetworkSystemError;

export { isTokenCredential }

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export interface MessageHeader {
    deliveryCount?: number;
    durable?: boolean;
    firstAcquirer?: boolean;
    priority?: number;
    ttl?: number;
}

// @public
export namespace MessageHeader {
    export function fromAmqpMessageHeader(props: AmqpMessageHeader): MessageHeader;
    export function toAmqpMessageHeader(props: MessageHeader): AmqpMessageHeader;
}

// @public
export interface MessageProperties {
    absoluteExpiryTime?: number;
    contentEncoding?: string;
    contentType?: string;
    correlationId?: string | number | Buffer;
    creationTime?: number;
    groupId?: string;
    groupSequence?: number;
    messageId?: string | number | Buffer;
    replyTo?: string;
    replyToGroupId?: string;
    subject?: string;
    to?: string;
    userId?: string;
}

// @public
export namespace MessageProperties {
    export function fromAmqpMessageProperties(props: AmqpMessageProperties): MessageProperties;
    export function toAmqpMessageProperties(props: MessageProperties): AmqpMessageProperties;
}

// @public
export class MessagingError extends Error {
    constructor(message: string, originalError?: Error);
    address?: string;
    code?: string;
    errno?: number | string;
    info?: any;
    name: string;
    port?: number;
    retryable: boolean;
    syscall?: string;
}

// @public
export function parseConnectionString<T>(connectionString: string): ParsedOutput<T>;

// @public
export type ParsedOutput<T> = {
    [P in keyof T]: T[P];
};

// @public
export function randomNumberFromInterval(min: number, max: number): number;

// @public
export class RequestResponseLink implements ReqResLink {
    constructor(session: Session, sender: Sender, receiver: Receiver);
    close(): Promise<void>;
    readonly connection: Connection;
    static create(connection: Connection, senderOptions: SenderOptions, receiverOptions: ReceiverOptions): Promise<RequestResponseLink>;
    isOpen(): boolean;
    // (undocumented)
    receiver: Receiver;
    remove(): void;
    // (undocumented)
    sender: Sender;
    sendRequest(request: AmqpMessage, options?: SendRequestOptions): Promise<AmqpMessage>;
    // (undocumented)
    session: Session;
}

// @public
export function retry<T>(config: RetryConfig<T>): Promise<T>;

// @public
export const retryableErrors: string[];

// @public
export interface RetryConfig<T> {
    abortSignal?: AbortSignalLike;
    connectionHost?: string;
    connectionId: string;
    operation: () => Promise<T>;
    operationType: RetryOperationType;
    retryOptions?: RetryOptions;
}

// @public
export enum RetryMode {
    // (undocumented)
    Exponential = 0,
    // (undocumented)
    Fixed = 1
}

// @public
export enum RetryOperationType {
    // (undocumented)
    cbsAuth = "cbsAuth",
    // (undocumented)
    connection = "connection",
    // (undocumented)
    management = "management",
    // (undocumented)
    receiveMessage = "receiveMessage",
    // (undocumented)
    receiverLink = "receiverLink",
    // (undocumented)
    senderLink = "senderLink",
    // (undocumented)
    sendMessage = "sendMessage",
    // (undocumented)
    session = "session"
}

// @public
export interface RetryOptions {
    maxRetries?: number;
    maxRetryDelayInMs?: number;
    mode?: RetryMode;
    retryDelayInMs?: number;
    timeoutInMs?: number;
}

// @public
export interface SendRequestOptions {
    abortSignal?: AbortSignalLike;
    requestName?: string;
    timeoutInMs?: number;
}

// @public
export interface ServiceBusConnectionStringModel {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    Endpoint: string;
    // (undocumented)
    EntityPath?: string;
    // (undocumented)
    SharedAccessKey: string;
    // (undocumented)
    SharedAccessKeyName: string;
}

// @public
export class SharedKeyCredential {
    constructor(keyName: string, key: string);
    protected _createToken(expiry: number, audience: string, hashInput?: string | Buffer): AccessToken;
    static fromConnectionString(connectionString: string): SharedKeyCredential;
    getToken(audience: string): AccessToken;
    key: string;
    keyName: string;
}

// @public
export interface StorageConnectionStringModel {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    AccountKey: string;
    // (undocumented)
    AccountName: string;
    // (undocumented)
    DefaultEndpointsProtocol: string;
    // (undocumented)
    EndpointSuffix: string;
}

// @public
export enum SystemErrorConditionMapper {
    // (undocumented)
    EBUSY = "com.microsoft:server-busy",
    // (undocumented)
    ECONNREFUSED = "amqp:connection:forced",
    // (undocumented)
    ECONNRESET = "com.microsoft:timeout",
    // (undocumented)
    EHOSTDOWN = "com.microsoft:timeout",
    // (undocumented)
    ENETDOWN = "com.microsoft:timeout",
    // (undocumented)
    ENETRESET = "com.microsoft:timeout",
    // (undocumented)
    ENETUNREACH = "com.microsoft:timeout",
    // (undocumented)
    ENONET = "com.microsoft:timeout",
    // (undocumented)
    ENOTFOUND = "amqp:not-found",
    // (undocumented)
    ETIMEDOUT = "com.microsoft:timeout"
}

// @public
export class Timeout {
    // (undocumented)
    clear(): void;
    // (undocumented)
    set<T>(t: number, value?: T): Promise<T>;
    // (undocumented)
    static set<T>(t: number, value?: T): Promise<T>;
    // (undocumented)
    wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T>;
    // (undocumented)
    static wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T>;
}

export { TokenCredential }

// @public
export enum TokenType {
    CbsTokenTypeJwt = "jwt",
    CbsTokenTypeSas = "servicebus.windows.net:sastoken"
}

// @public
export function translate(err: AmqpError | Error): MessagingError | Error;


// (No @packageDocumentation comment for this package)

```
